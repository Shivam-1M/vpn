//! Main entry point for the VPN Data Plane service.
//! This service is responsible for creating and managing a WireGuard interface
//! and exposing a gRPC API for the Control Plane to manage peers.

use base64::{engine::general_purpose, Engine as _};
use defguard_wireguard_rs::{
    host::Peer, InterfaceConfiguration, Userspace, WGApi, WireguardInterfaceApi,
};
use log;
use std::error::Error;
use std::sync::Arc;
use tokio::sync::Mutex;
use tonic::{transport::Server, Request, Response, Status};
use x25519_dalek::{PublicKey, StaticSecret};

// These modules are generated by `tonic-build` in build.rs from vpn.proto
pub mod vpn {
    tonic::include_proto!("vpn");
}
use vpn::vpn_manager_server::{VpnManager, VpnManagerServer};
use vpn::{PeerRequest, PeerResponse};

// A struct to hold the state of our gRPC service, namely a thread-safe
// reference to the WireGuard API.
pub struct VpnManagerService {
    wgapi: Arc<WGApi<Userspace>>,
}

// Implementation of the gRPC service trait.
#[tonic::async_trait]
impl VpnManager for VpnManagerService {
    // Handler for the AddPeer RPC call.
    async fn add_peer(
        &self,
        request: Request<PeerRequest>,
    ) -> Result<Response<PeerResponse>, Status> {
        let public_key_b64 = request.into_inner().public_key;
        log::info!("gRPC: Received AddPeer request for key: {}", public_key_b64);

        // Decode the public key from base64.
        let public_key_bytes = match general_purpose::STANDARD.decode(&public_key_b64) {
            Ok(bytes) if bytes.len() == 32 => {
                let mut arr = [0u8; 32];
                arr.copy_from_slice(&bytes);
                arr
            }
            _ => {
                return Err(Status::invalid_argument("Invalid public key format"));
            }
        };

        // Create a new peer configuration.
        // In a real VPN, you would also assign an IP from a pool here.
        let public_key = defguard_wireguard_rs::key::Key::new(public_key_bytes);
        let mut peer = Peer::new(public_key);
        peer.allowed_ips.push("10.10.10.2/32".parse().unwrap()); // Placeholder IP

        // Use the WireGuard API to add the peer to the running interface.
        if let Err(e) = self.wgapi.configure_peer(&peer) {
            log::error!("gRPC: Failed to configure peer: {}", e);
            return Err(Status::internal("Failed to configure peer"));
        }

        log::info!(
            "gRPC: Successfully configured peer with key: {}",
            public_key_b64
        );
        let reply = PeerResponse {
            success: true,
            message: format!("Peer {} added successfully", public_key_b64),
        };
        Ok(Response::new(reply))
    }

    // Handler for the RemovePeer RPC call (placeholder for now).
    async fn remove_peer(
        &self,
        _request: Request<PeerRequest>,
    ) -> Result<Response<PeerResponse>, Status> {
        // In a real implementation, you would use `wgapi.remove_peer(...)`
        log::warn!("gRPC: RemovePeer is not yet implemented.");
        Err(Status::unimplemented("RemovePeer is not yet implemented"))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Use `env_logger` for logging. `RUST_LOG=info cargo run` to see logs.
    env_logger::init();

    log::info!("Initializing VPN Data Plane...");

    let ifname: String = if cfg!(target_os = "linux") || cfg!(target_os = "freebsd") {
        "wg0".into()
    } else {
        "utun3".into()
    };

    let server_private_key_b64 = "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8=";
    let server_private_key_bytes: [u8; 32] = general_purpose::STANDARD
        .decode(server_private_key_b64)?
        .try_into()
        .expect("Private key is not 32 bytes long after base64 decoding");

    let secret = StaticSecret::from(server_private_key_bytes);
    let public_key = PublicKey::from(&secret);

    let wgapi = Arc::new(WGApi::<Userspace>::new(ifname.clone())?);
    wgapi.create_interface()?;

    let config = InterfaceConfiguration {
        name: ifname,
        prvkey: server_private_key_b64.to_string(),
        addresses: vec!["10.10.10.1/24".parse()?],
        port: 51820,
        peers: vec![],
        mtu: None,
    };
    wgapi.configure_interface(&config)?;

    log::info!(
        "WireGuard backend initialized. Public Key: {}",
        general_purpose::STANDARD.encode(public_key.as_bytes())
    );
    log::info!("WireGuard listening on UDP port 51820.");

    // --- Start gRPC Server ---
    let grpc_addr = "0.0.0.0:50051".parse()?;
    let vpn_service = VpnManagerService {
        wgapi: Arc::clone(&wgapi),
    };
    let grpc_server = VpnManagerServer::new(vpn_service);

    log::info!("gRPC server listening on {}", grpc_addr);

    // Spawn the gRPC server as a separate, non-blocking task.
    tokio::spawn(async move {
        if let Err(e) = Server::builder()
            .add_service(grpc_server)
            .serve(grpc_addr)
            .await
        {
            log::error!("gRPC server failed: {}", e);
        }
    });

    // Keep the main thread alive to keep the WireGuard interface running.
    tokio::time::sleep(tokio::time::Duration::from_secs(u64::MAX)).await;

    Ok(())
}
