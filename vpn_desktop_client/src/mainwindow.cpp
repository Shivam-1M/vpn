#include "mainwindow.h"
// This header is generated by Qt's build system from mainwindow.ui
#include "ui_mainwindow.h"

#include <QMessageBox>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow), vpnClient(nullptr), isConnected(false)
{
    ui->setupUi(this);

    // Create the Rust client instance when the window is created.
    vpnClient = vpn_client_create();
    if (!vpnClient)
    {
        QMessageBox::critical(this, "Error", "Failed to initialize VPN client core.");
        // Disable the button if the core library failed to load.
        ui->connectButton->setEnabled(false);
        ui->loginGroup->setEnabled(false);
    }

    // Initialize the network manager
    networkManager = new QNetworkAccessManager(this);

    // Connect the buttons' clicked signals to our handler slots.
    connect(ui->connectButton, &QPushButton::clicked, this, &MainWindow::onConnectButtonClicked);
    connect(ui->loginButton, &QPushButton::clicked, this, &MainWindow::onLoginButtonClicked);
    // ADD THIS
    connect(ui->registerDeviceButton, &QPushButton::clicked, this, &MainWindow::onRegisterDeviceButtonClicked);
}

MainWindow::~MainWindow()
{
    // Clean up the Rust client instance when the window is closed.
    if (vpnClient)
    {
        if (isConnected)
        {
            vpn_client_disconnect(vpnClient);
        }
        vpn_client_destroy(vpnClient);
    }
    delete ui;
}

void MainWindow::onLoginButtonClicked()
{
    QString email = ui->emailLineEdit->text();
    QString password = ui->passwordLineEdit->text();

    if (email.isEmpty() || password.isEmpty())
    {
        QMessageBox::warning(this, "Login Failed", "Please enter both email and password.");
        return;
    }

    // Create the JSON payload
    QJsonObject json;
    json["email"] = email;
    json["password"] = password;
    QJsonDocument doc(json);
    QByteArray data = doc.toJson();

    // Create and send the request
    QNetworkRequest request(QUrl("http://localhost:8080/login"));
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");

    QNetworkReply *reply = networkManager->post(request, data);
    connect(reply, &QNetworkReply::finished, this, [=]()
            { onLoginReplyFinished(reply); });
}

void MainWindow::onLoginReplyFinished(QNetworkReply *reply)
{
    if (reply->error() == QNetworkReply::NoError)
    {
        QByteArray response_data = reply->readAll();
        QJsonDocument jsonDoc = QJsonDocument::fromJson(response_data);
        QJsonObject jsonObj = jsonDoc.object();

        if (jsonObj.contains("token") && jsonObj["token"].isString())
        {
            jwtToken = jsonObj["token"].toString();
            QMessageBox::information(this, "Login Success", "Successfully logged in!");

            // Enable the device registration section
            ui->loginGroup->setEnabled(false);
            ui->deviceGroup->setEnabled(true);
        }
        else
        {
            QMessageBox::critical(this, "Login Failed", "Invalid credentials or server error.");
        }
    }
    else
    {
        QMessageBox::critical(this, "Login Failed", "Error: " + reply->errorString());
    }
    reply->deleteLater();
}

// ADD THIS ENTIRE FUNCTION
void MainWindow::onRegisterDeviceButtonClicked()
{
    // 1. Generate a new key pair using the Rust library
    VpnKeyPair keypair = vpn_generate_keypair();
    QString publicKey = QString::fromUtf8(keypair.public_key);
    // Store the private key in our config struct
    vpnConfig.clientPrivateKey = QString::fromUtf8(keypair.private_key);

    // IMPORTANT: Free the strings that Rust allocated to prevent memory leaks
    vpn_free_string(keypair.public_key);
    vpn_free_string(keypair.private_key);

    // 2. Send the public key to the server
    QJsonObject json;
    json["public_key"] = publicKey;
    QJsonDocument doc(json);
    QByteArray data = doc.toJson();

    QNetworkRequest request(QUrl("http://localhost:8080/devices"));
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    QString authHeader = "Bearer " + jwtToken;
    request.setRawHeader("Authorization", authHeader.toUtf8());

    QNetworkReply *reply = networkManager->post(request, data);
    connect(reply, &QNetworkReply::finished, this, [=]()
            { onDeviceReplyFinished(reply); });
}

// ADD THIS ENTIRE FUNCTION
void MainWindow::onDeviceReplyFinished(QNetworkReply *reply)
{
    if (reply->error() == QNetworkReply::NoError)
    {
        QMessageBox::information(this, "Device Registered", "Device successfully registered! Now fetching config...");

        // 3. Now that the device is registered, get the VPN config
        QNetworkRequest request(QUrl("http://localhost:8080/config"));
        QString authHeader = "Bearer " + jwtToken;
        request.setRawHeader("Authorization", authHeader.toUtf8());

        QNetworkReply *configReply = networkManager->get(request);
        connect(configReply, &QNetworkReply::finished, this, [=]()
                { onConfigReplyFinished(configReply); });
    }
    else
    {
        QMessageBox::critical(this, "Device Registration Failed", "Error: " + reply->errorString());
    }
    reply->deleteLater();
}

void MainWindow::onConfigReplyFinished(QNetworkReply *reply)
{
    if (reply->error() == QNetworkReply::NoError)
    {
        QByteArray response_data = reply->readAll();
        QJsonDocument jsonDoc = QJsonDocument::fromJson(response_data);
        QJsonObject jsonObj = jsonDoc.object();

        // Populate our config struct (we already have the private key)
        vpnConfig.clientIp = jsonObj["client_ip"].toString();
        vpnConfig.dnsServer = jsonObj["dns_server"].toString();
        vpnConfig.serverPublicKey = jsonObj["server_public_key"].toString();
        vpnConfig.serverEndpoint = jsonObj["server_endpoint"].toString();

        if (vpnConfig.clientIp.isEmpty() || vpnConfig.serverEndpoint.isEmpty())
        {
            QMessageBox::critical(this, "Config Error", "Failed to parse VPN configuration from server.");
            return;
        }

        QMessageBox::information(this, "Config Received", "VPN configuration loaded successfully.");
        ui->connectButton->setEnabled(true); // Enable the connect button
        ui->deviceGroup->setEnabled(false);  // Disable device registration
    }
    else
    {
        QMessageBox::critical(this, "Config Error", "Could not fetch VPN config: " + reply->errorString());
    }
    reply->deleteLater();
}

void MainWindow::onConnectButtonClicked()
{
    if (!isConnected)
    {
        // Use the config we fetched from the server and our generated key
        if (vpn_client_connect(vpnClient,
                               vpnConfig.clientPrivateKey.toStdString().c_str(),
                               vpnConfig.clientIp.toStdString().c_str(),
                               vpnConfig.dnsServer.toStdString().c_str(),
                               vpnConfig.serverPublicKey.toStdString().c_str(),
                               vpnConfig.serverEndpoint.toStdString().c_str()) == 0)
        {
            ui->statusLabel->setText("Status: Connected");
            ui->connectButton->setText("Disconnect");
            isConnected = true;
        }
        else
        {
            QMessageBox::warning(this, "Connection Failed", "Could not connect to the VPN server.");
        }
    }
    else
    {
        if (vpn_client_disconnect(vpnClient) == 0)
        {
            ui->statusLabel->setText("Status: Disconnected");
            ui->connectButton->setText("Connect");
            isConnected = false;
        }
        else
        {
            QMessageBox::warning(this, "Disconnection Failed", "Could not disconnect from the VPN server.");
        }
    }
}